
SR2019_ledtest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004fc  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000570  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000078  00800060  00800060  00000570  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000570  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000005a0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000020  00000000  00000000  000005e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001234  00000000  00000000  00000600  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000580  00000000  00000000  00001834  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000075c  00000000  00000000  00001db4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000024  00000000  00000000  00002510  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000042a  00000000  00000000  00002534  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001239  00000000  00000000  0000295e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000010  00000000  00000000  00003b97  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	1f c0       	rjmp	.+62     	; 0x42 <__bad_interrupt>
   4:	1e c0       	rjmp	.+60     	; 0x42 <__bad_interrupt>
   6:	1d c0       	rjmp	.+58     	; 0x42 <__bad_interrupt>
   8:	1c c0       	rjmp	.+56     	; 0x42 <__bad_interrupt>
   a:	1b c0       	rjmp	.+54     	; 0x42 <__bad_interrupt>
   c:	1a c0       	rjmp	.+52     	; 0x42 <__bad_interrupt>
   e:	19 c0       	rjmp	.+50     	; 0x42 <__bad_interrupt>
  10:	18 c0       	rjmp	.+48     	; 0x42 <__bad_interrupt>
  12:	17 c0       	rjmp	.+46     	; 0x42 <__bad_interrupt>
  14:	16 c0       	rjmp	.+44     	; 0x42 <__bad_interrupt>
  16:	15 c0       	rjmp	.+42     	; 0x42 <__bad_interrupt>
  18:	14 c0       	rjmp	.+40     	; 0x42 <__bad_interrupt>
  1a:	13 c0       	rjmp	.+38     	; 0x42 <__bad_interrupt>
  1c:	12 c0       	rjmp	.+36     	; 0x42 <__bad_interrupt>
  1e:	11 c0       	rjmp	.+34     	; 0x42 <__bad_interrupt>
  20:	10 c0       	rjmp	.+32     	; 0x42 <__bad_interrupt>
  22:	0f c0       	rjmp	.+30     	; 0x42 <__bad_interrupt>
  24:	0e c0       	rjmp	.+28     	; 0x42 <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf ed       	ldi	r28, 0xDF	; 223
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_clear_bss>:
  2e:	20 e0       	ldi	r18, 0x00	; 0
  30:	a0 e6       	ldi	r26, 0x60	; 96
  32:	b0 e0       	ldi	r27, 0x00	; 0
  34:	01 c0       	rjmp	.+2      	; 0x38 <.do_clear_bss_start>

00000036 <.do_clear_bss_loop>:
  36:	1d 92       	st	X+, r1

00000038 <.do_clear_bss_start>:
  38:	a8 3d       	cpi	r26, 0xD8	; 216
  3a:	b2 07       	cpc	r27, r18
  3c:	e1 f7       	brne	.-8      	; 0x36 <.do_clear_bss_loop>
  3e:	02 d0       	rcall	.+4      	; 0x44 <main>
  40:	5b c2       	rjmp	.+1206   	; 0x4f8 <_exit>

00000042 <__bad_interrupt>:
  42:	de cf       	rjmp	.-68     	; 0x0 <__vectors>

00000044 <main>:
				if(a == i){
					led[i].r = 10;
					led[i].g = 255;
					led[i].b = 10;					
				}else{
					led[i].r = 30;
  44:	7e e1       	ldi	r23, 0x1E	; 30
					led[i].g = 10;
  46:	aa e0       	ldi	r26, 0x0A	; 10
		for (a=0; a<numLeds; a++){
			for (i=0; i<numLeds; i++)
			{	
				if(a == i){
					led[i].r = 10;
					led[i].g = 255;
  48:	bf ef       	ldi	r27, 0xFF	; 255
  4a:	48 ed       	ldi	r20, 0xD8	; 216
  4c:	50 e0       	ldi	r21, 0x00	; 0
  4e:	20 e6       	ldi	r18, 0x60	; 96
  50:	30 e0       	ldi	r19, 0x00	; 0
  52:	ca 01       	movw	r24, r20
		ws2812_setleds(led,numLeds);
		_delay_ms(500);
		
		*/
		//Individual
		for (a=0; a<numLeds; a++){
  54:	c0 e0       	ldi	r28, 0x00	; 0
  56:	e0 e6       	ldi	r30, 0x60	; 96
  58:	f0 e0       	ldi	r31, 0x00	; 0
  5a:	60 e0       	ldi	r22, 0x00	; 0
			for (i=0; i<numLeds; i++)
			{	
				if(a == i){
  5c:	c6 13       	cpse	r28, r22
  5e:	04 c0       	rjmp	.+8      	; 0x68 <main+0x24>
					led[i].r = 10;
  60:	a1 83       	std	Z+1, r26	; 0x01
					led[i].g = 255;
  62:	b0 83       	st	Z, r27
					led[i].b = 10;					
  64:	a2 83       	std	Z+2, r26	; 0x02
  66:	03 c0       	rjmp	.+6      	; 0x6e <main+0x2a>
				}else{
					led[i].r = 30;
  68:	71 83       	std	Z+1, r23	; 0x01
					led[i].g = 10;
  6a:	a0 83       	st	Z, r26
					led[i].b = 30;					
  6c:	72 83       	std	Z+2, r23	; 0x02
		_delay_ms(500);
		
		*/
		//Individual
		for (a=0; a<numLeds; a++){
			for (i=0; i<numLeds; i++)
  6e:	6f 5f       	subi	r22, 0xFF	; 255
  70:	33 96       	adiw	r30, 0x03	; 3
  72:	68 32       	cpi	r22, 0x28	; 40
  74:	99 f7       	brne	.-26     	; 0x5c <main+0x18>
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
	uint8_t curbyte,ctr,masklo;
	uint8_t sreg_prev;
	
	ws2812_DDRREG |= maskhi; // Enable output
  76:	b9 9a       	sbi	0x17, 1	; 23
	
	masklo	=~maskhi&ws2812_PORTREG;
  78:	18 b3       	in	r17, 0x18	; 24
  7a:	1d 7f       	andi	r17, 0xFD	; 253
	maskhi |=        ws2812_PORTREG;
  7c:	d8 b3       	in	r29, 0x18	; 24
  7e:	d2 60       	ori	r29, 0x02	; 2
	
	sreg_prev=SREG;
  80:	ff b6       	in	r15, 0x3f	; 63
	cli();
  82:	f8 94       	cli
  84:	e0 e6       	ldi	r30, 0x60	; 96
  86:	f0 e0       	ldi	r31, 0x00	; 0

	while (datlen--) {
		curbyte=*data++;
  88:	61 91       	ld	r22, Z+

		"       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
		"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
  8a:	08 e0       	ldi	r16, 0x08	; 8

0000008c <loop93>:
  8c:	d8 bb       	out	0x18, r29	; 24
  8e:	00 00       	nop
  90:	00 c0       	rjmp	.+0      	; 0x92 <loop93+0x6>
  92:	00 c0       	rjmp	.+0      	; 0x94 <loop93+0x8>
  94:	67 ff       	sbrs	r22, 7
  96:	18 bb       	out	0x18, r17	; 24
  98:	66 0f       	add	r22, r22
  9a:	00 00       	nop
  9c:	00 c0       	rjmp	.+0      	; 0x9e <loop93+0x12>
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <loop93+0x14>
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <loop93+0x16>
  a2:	00 c0       	rjmp	.+0      	; 0xa4 <loop93+0x18>
  a4:	18 bb       	out	0x18, r17	; 24
  a6:	00 00       	nop
  a8:	00 c0       	rjmp	.+0      	; 0xaa <loop93+0x1e>
  aa:	0a 95       	dec	r16
  ac:	79 f7       	brne	.-34     	; 0x8c <loop93>
	maskhi |=        ws2812_PORTREG;
	
	sreg_prev=SREG;
	cli();

	while (datlen--) {
  ae:	4e 17       	cp	r20, r30
  b0:	5f 07       	cpc	r21, r31
  b2:	51 f7       	brne	.-44     	; 0x88 <main+0x44>
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	
	SREG=sreg_prev;
  b4:	ff be       	out	0x3f, r15	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  b6:	eb ed       	ldi	r30, 0xDB	; 219
  b8:	f5 e0       	ldi	r31, 0x05	; 5
  ba:	31 97       	sbiw	r30, 0x01	; 1
  bc:	f1 f7       	brne	.-4      	; 0xba <loop93+0x2e>
  be:	00 c0       	rjmp	.+0      	; 0xc0 <loop93+0x34>
  c0:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  c2:	ff e7       	ldi	r31, 0x7F	; 127
  c4:	6a e1       	ldi	r22, 0x1A	; 26
  c6:	e6 e0       	ldi	r30, 0x06	; 6
  c8:	f1 50       	subi	r31, 0x01	; 1
  ca:	60 40       	sbci	r22, 0x00	; 0
  cc:	e0 40       	sbci	r30, 0x00	; 0
  ce:	e1 f7       	brne	.-8      	; 0xc8 <loop93+0x3c>
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <loop93+0x46>
  d2:	00 00       	nop
		ws2812_setleds(led,numLeds);
		_delay_ms(500);
		
		*/
		//Individual
		for (a=0; a<numLeds; a++){
  d4:	cf 5f       	subi	r28, 0xFF	; 255
  d6:	c8 32       	cpi	r28, 0x28	; 40
  d8:	09 f0       	breq	.+2      	; 0xdc <loop93+0x50>
  da:	bd cf       	rjmp	.-134    	; 0x56 <main+0x12>
  dc:	ff e7       	ldi	r31, 0x7F	; 127
  de:	64 e8       	ldi	r22, 0x84	; 132
  e0:	ee e1       	ldi	r30, 0x1E	; 30
  e2:	f1 50       	subi	r31, 0x01	; 1
  e4:	60 40       	sbci	r22, 0x00	; 0
  e6:	e0 40       	sbci	r30, 0x00	; 0
  e8:	e1 f7       	brne	.-8      	; 0xe2 <__stack+0x3>
  ea:	00 c0       	rjmp	.+0      	; 0xec <__stack+0xd>
  ec:	00 00       	nop
		}
		_delay_ms(500);
		////////////////////////////////////////////////////////////////////////////////
		//White
		//Fast fade
		for (f=0; f<255; f++){
  ee:	60 e0       	ldi	r22, 0x00	; 0
  f0:	f9 01       	movw	r30, r18
			for (i=0; i<numLeds; i++)
			{
				led[i].r = f;
  f2:	61 83       	std	Z+1, r22	; 0x01
				led[i].g = f;
  f4:	60 83       	st	Z, r22
				led[i].b = f;
  f6:	62 83       	std	Z+2, r22	; 0x02
  f8:	33 96       	adiw	r30, 0x03	; 3
		_delay_ms(500);
		////////////////////////////////////////////////////////////////////////////////
		//White
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
  fa:	8e 17       	cp	r24, r30
  fc:	9f 07       	cpc	r25, r31
  fe:	c9 f7       	brne	.-14     	; 0xf2 <__stack+0x13>
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
	uint8_t curbyte,ctr,masklo;
	uint8_t sreg_prev;
	
	ws2812_DDRREG |= maskhi; // Enable output
 100:	b9 9a       	sbi	0x17, 1	; 23
	
	masklo	=~maskhi&ws2812_PORTREG;
 102:	18 b3       	in	r17, 0x18	; 24
 104:	1d 7f       	andi	r17, 0xFD	; 253
	maskhi |=        ws2812_PORTREG;
 106:	d8 b3       	in	r29, 0x18	; 24
 108:	d2 60       	ori	r29, 0x02	; 2
	
	sreg_prev=SREG;
 10a:	ff b6       	in	r15, 0x3f	; 63
	cli();
 10c:	f8 94       	cli
 10e:	f9 01       	movw	r30, r18

	while (datlen--) {
		curbyte=*data++;
 110:	c1 91       	ld	r28, Z+

		"       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
		"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
 112:	08 e0       	ldi	r16, 0x08	; 8

00000114 <loop221>:
 114:	d8 bb       	out	0x18, r29	; 24
 116:	00 00       	nop
 118:	00 c0       	rjmp	.+0      	; 0x11a <loop221+0x6>
 11a:	00 c0       	rjmp	.+0      	; 0x11c <loop221+0x8>
 11c:	c7 ff       	sbrs	r28, 7
 11e:	18 bb       	out	0x18, r17	; 24
 120:	cc 0f       	add	r28, r28
 122:	00 00       	nop
 124:	00 c0       	rjmp	.+0      	; 0x126 <loop221+0x12>
 126:	00 c0       	rjmp	.+0      	; 0x128 <loop221+0x14>
 128:	00 c0       	rjmp	.+0      	; 0x12a <loop221+0x16>
 12a:	00 c0       	rjmp	.+0      	; 0x12c <loop221+0x18>
 12c:	18 bb       	out	0x18, r17	; 24
 12e:	00 00       	nop
 130:	00 c0       	rjmp	.+0      	; 0x132 <loop221+0x1e>
 132:	0a 95       	dec	r16
 134:	79 f7       	brne	.-34     	; 0x114 <loop221>
	maskhi |=        ws2812_PORTREG;
	
	sreg_prev=SREG;
	cli();

	while (datlen--) {
 136:	8e 17       	cp	r24, r30
 138:	9f 07       	cpc	r25, r31
 13a:	51 f7       	brne	.-44     	; 0x110 <__stack+0x31>
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	
	SREG=sreg_prev;
 13c:	ff be       	out	0x3f, r15	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 13e:	eb ed       	ldi	r30, 0xDB	; 219
 140:	f5 e0       	ldi	r31, 0x05	; 5
 142:	31 97       	sbiw	r30, 0x01	; 1
 144:	f1 f7       	brne	.-4      	; 0x142 <loop221+0x2e>
 146:	00 c0       	rjmp	.+0      	; 0x148 <loop221+0x34>
 148:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 14a:	ef e4       	ldi	r30, 0x4F	; 79
 14c:	f3 ec       	ldi	r31, 0xC3	; 195
 14e:	31 97       	sbiw	r30, 0x01	; 1
 150:	f1 f7       	brne	.-4      	; 0x14e <loop221+0x3a>
 152:	00 c0       	rjmp	.+0      	; 0x154 <loop221+0x40>
 154:	00 00       	nop
		}
		_delay_ms(500);
		////////////////////////////////////////////////////////////////////////////////
		//White
		//Fast fade
		for (f=0; f<255; f++){
 156:	6f 5f       	subi	r22, 0xFF	; 255
 158:	6f 3f       	cpi	r22, 0xFF	; 255
 15a:	09 f0       	breq	.+2      	; 0x15e <loop221+0x4a>
 15c:	c9 cf       	rjmp	.-110    	; 0xf0 <__stack+0x11>
 15e:	ff e7       	ldi	r31, 0x7F	; 127
 160:	64 e8       	ldi	r22, 0x84	; 132
 162:	ee e1       	ldi	r30, 0x1E	; 30
 164:	f1 50       	subi	r31, 0x01	; 1
 166:	60 40       	sbci	r22, 0x00	; 0
 168:	e0 40       	sbci	r30, 0x00	; 0
 16a:	e1 f7       	brne	.-8      	; 0x164 <loop221+0x50>
 16c:	00 c0       	rjmp	.+0      	; 0x16e <loop221+0x5a>
 16e:	00 00       	nop
 170:	6f ef       	ldi	r22, 0xFF	; 255
 172:	f9 01       	movw	r30, r18
		
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
			{
				led[i].r = 255-f;
 174:	61 83       	std	Z+1, r22	; 0x01
				led[i].g = 255-f;
 176:	60 83       	st	Z, r22
				led[i].b = 255-f;
 178:	62 83       	std	Z+2, r22	; 0x02
 17a:	33 96       	adiw	r30, 0x03	; 3
		}
		_delay_ms(500);
		
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
 17c:	8e 17       	cp	r24, r30
 17e:	9f 07       	cpc	r25, r31
 180:	c9 f7       	brne	.-14     	; 0x174 <loop221+0x60>
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
	uint8_t curbyte,ctr,masklo;
	uint8_t sreg_prev;
	
	ws2812_DDRREG |= maskhi; // Enable output
 182:	b9 9a       	sbi	0x17, 1	; 23
	
	masklo	=~maskhi&ws2812_PORTREG;
 184:	18 b3       	in	r17, 0x18	; 24
 186:	1d 7f       	andi	r17, 0xFD	; 253
	maskhi |=        ws2812_PORTREG;
 188:	d8 b3       	in	r29, 0x18	; 24
 18a:	d2 60       	ori	r29, 0x02	; 2
	
	sreg_prev=SREG;
 18c:	ff b6       	in	r15, 0x3f	; 63
	cli();
 18e:	f8 94       	cli
 190:	f9 01       	movw	r30, r18

	while (datlen--) {
		curbyte=*data++;
 192:	c1 91       	ld	r28, Z+

		"       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
		"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
 194:	08 e0       	ldi	r16, 0x08	; 8

00000196 <loop349>:
 196:	d8 bb       	out	0x18, r29	; 24
 198:	00 00       	nop
 19a:	00 c0       	rjmp	.+0      	; 0x19c <loop349+0x6>
 19c:	00 c0       	rjmp	.+0      	; 0x19e <loop349+0x8>
 19e:	c7 ff       	sbrs	r28, 7
 1a0:	18 bb       	out	0x18, r17	; 24
 1a2:	cc 0f       	add	r28, r28
 1a4:	00 00       	nop
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <loop349+0x12>
 1a8:	00 c0       	rjmp	.+0      	; 0x1aa <loop349+0x14>
 1aa:	00 c0       	rjmp	.+0      	; 0x1ac <loop349+0x16>
 1ac:	00 c0       	rjmp	.+0      	; 0x1ae <loop349+0x18>
 1ae:	18 bb       	out	0x18, r17	; 24
 1b0:	00 00       	nop
 1b2:	00 c0       	rjmp	.+0      	; 0x1b4 <loop349+0x1e>
 1b4:	0a 95       	dec	r16
 1b6:	79 f7       	brne	.-34     	; 0x196 <loop349>
	maskhi |=        ws2812_PORTREG;
	
	sreg_prev=SREG;
	cli();

	while (datlen--) {
 1b8:	8e 17       	cp	r24, r30
 1ba:	9f 07       	cpc	r25, r31
 1bc:	51 f7       	brne	.-44     	; 0x192 <loop221+0x7e>
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	
	SREG=sreg_prev;
 1be:	ff be       	out	0x3f, r15	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1c0:	eb ed       	ldi	r30, 0xDB	; 219
 1c2:	f5 e0       	ldi	r31, 0x05	; 5
 1c4:	31 97       	sbiw	r30, 0x01	; 1
 1c6:	f1 f7       	brne	.-4      	; 0x1c4 <loop349+0x2e>
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <loop349+0x34>
 1ca:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1cc:	ef e4       	ldi	r30, 0x4F	; 79
 1ce:	f3 ec       	ldi	r31, 0xC3	; 195
 1d0:	31 97       	sbiw	r30, 0x01	; 1
 1d2:	f1 f7       	brne	.-4      	; 0x1d0 <loop349+0x3a>
 1d4:	00 c0       	rjmp	.+0      	; 0x1d6 <loop349+0x40>
 1d6:	00 00       	nop
 1d8:	61 50       	subi	r22, 0x01	; 1
			_delay_ms(10);
		}
		_delay_ms(500);
		
		//Fast fade
		for (f=0; f<255; f++){
 1da:	09 f0       	breq	.+2      	; 0x1de <loop349+0x48>
 1dc:	ca cf       	rjmp	.-108    	; 0x172 <loop221+0x5e>
 1de:	ff e7       	ldi	r31, 0x7F	; 127
 1e0:	64 e8       	ldi	r22, 0x84	; 132
 1e2:	ee e1       	ldi	r30, 0x1E	; 30
 1e4:	f1 50       	subi	r31, 0x01	; 1
 1e6:	60 40       	sbci	r22, 0x00	; 0
 1e8:	e0 40       	sbci	r30, 0x00	; 0
 1ea:	e1 f7       	brne	.-8      	; 0x1e4 <loop349+0x4e>
 1ec:	00 c0       	rjmp	.+0      	; 0x1ee <loop349+0x58>
 1ee:	00 00       	nop
		}
		_delay_ms(500);
		////////////////////////////////////////////////////////////////////////////////
		//Red
		//Fast fade
		for (f=0; f<255; f++){
 1f0:	60 e0       	ldi	r22, 0x00	; 0
 1f2:	f9 01       	movw	r30, r18
			for (i=0; i<numLeds; i++)
			{
				led[i].r = f;
 1f4:	61 83       	std	Z+1, r22	; 0x01
				led[i].g = 0;
 1f6:	10 82       	st	Z, r1
				led[i].b = 0;
 1f8:	12 82       	std	Z+2, r1	; 0x02
 1fa:	33 96       	adiw	r30, 0x03	; 3
		_delay_ms(500);
		////////////////////////////////////////////////////////////////////////////////
		//Red
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
 1fc:	8e 17       	cp	r24, r30
 1fe:	9f 07       	cpc	r25, r31
 200:	c9 f7       	brne	.-14     	; 0x1f4 <loop349+0x5e>
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
	uint8_t curbyte,ctr,masklo;
	uint8_t sreg_prev;
	
	ws2812_DDRREG |= maskhi; // Enable output
 202:	b9 9a       	sbi	0x17, 1	; 23
	
	masklo	=~maskhi&ws2812_PORTREG;
 204:	18 b3       	in	r17, 0x18	; 24
 206:	1d 7f       	andi	r17, 0xFD	; 253
	maskhi |=        ws2812_PORTREG;
 208:	d8 b3       	in	r29, 0x18	; 24
 20a:	d2 60       	ori	r29, 0x02	; 2
	
	sreg_prev=SREG;
 20c:	ff b6       	in	r15, 0x3f	; 63
	cli();
 20e:	f8 94       	cli
 210:	f9 01       	movw	r30, r18

	while (datlen--) {
		curbyte=*data++;
 212:	c1 91       	ld	r28, Z+

		"       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
		"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
 214:	08 e0       	ldi	r16, 0x08	; 8

00000216 <loop477>:
 216:	d8 bb       	out	0x18, r29	; 24
 218:	00 00       	nop
 21a:	00 c0       	rjmp	.+0      	; 0x21c <loop477+0x6>
 21c:	00 c0       	rjmp	.+0      	; 0x21e <loop477+0x8>
 21e:	c7 ff       	sbrs	r28, 7
 220:	18 bb       	out	0x18, r17	; 24
 222:	cc 0f       	add	r28, r28
 224:	00 00       	nop
 226:	00 c0       	rjmp	.+0      	; 0x228 <loop477+0x12>
 228:	00 c0       	rjmp	.+0      	; 0x22a <loop477+0x14>
 22a:	00 c0       	rjmp	.+0      	; 0x22c <loop477+0x16>
 22c:	00 c0       	rjmp	.+0      	; 0x22e <loop477+0x18>
 22e:	18 bb       	out	0x18, r17	; 24
 230:	00 00       	nop
 232:	00 c0       	rjmp	.+0      	; 0x234 <loop477+0x1e>
 234:	0a 95       	dec	r16
 236:	79 f7       	brne	.-34     	; 0x216 <loop477>
	maskhi |=        ws2812_PORTREG;
	
	sreg_prev=SREG;
	cli();

	while (datlen--) {
 238:	8e 17       	cp	r24, r30
 23a:	9f 07       	cpc	r25, r31
 23c:	51 f7       	brne	.-44     	; 0x212 <loop349+0x7c>
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	
	SREG=sreg_prev;
 23e:	ff be       	out	0x3f, r15	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 240:	eb ed       	ldi	r30, 0xDB	; 219
 242:	f5 e0       	ldi	r31, 0x05	; 5
 244:	31 97       	sbiw	r30, 0x01	; 1
 246:	f1 f7       	brne	.-4      	; 0x244 <loop477+0x2e>
 248:	00 c0       	rjmp	.+0      	; 0x24a <loop477+0x34>
 24a:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 24c:	ef e4       	ldi	r30, 0x4F	; 79
 24e:	f3 ec       	ldi	r31, 0xC3	; 195
 250:	31 97       	sbiw	r30, 0x01	; 1
 252:	f1 f7       	brne	.-4      	; 0x250 <loop477+0x3a>
 254:	00 c0       	rjmp	.+0      	; 0x256 <loop477+0x40>
 256:	00 00       	nop
		}
		_delay_ms(500);
		////////////////////////////////////////////////////////////////////////////////
		//Red
		//Fast fade
		for (f=0; f<255; f++){
 258:	6f 5f       	subi	r22, 0xFF	; 255
 25a:	6f 3f       	cpi	r22, 0xFF	; 255
 25c:	09 f0       	breq	.+2      	; 0x260 <loop477+0x4a>
 25e:	c9 cf       	rjmp	.-110    	; 0x1f2 <loop349+0x5c>
 260:	ff e7       	ldi	r31, 0x7F	; 127
 262:	64 e8       	ldi	r22, 0x84	; 132
 264:	ee e1       	ldi	r30, 0x1E	; 30
 266:	f1 50       	subi	r31, 0x01	; 1
 268:	60 40       	sbci	r22, 0x00	; 0
 26a:	e0 40       	sbci	r30, 0x00	; 0
 26c:	e1 f7       	brne	.-8      	; 0x266 <loop477+0x50>
 26e:	00 c0       	rjmp	.+0      	; 0x270 <loop477+0x5a>
 270:	00 00       	nop
 272:	6f ef       	ldi	r22, 0xFF	; 255
 274:	f9 01       	movw	r30, r18
		
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
			{
				led[i].r = 255-f;
 276:	61 83       	std	Z+1, r22	; 0x01
				led[i].g = 0;
 278:	10 82       	st	Z, r1
				led[i].b = 0;
 27a:	12 82       	std	Z+2, r1	; 0x02
 27c:	33 96       	adiw	r30, 0x03	; 3
		}
		_delay_ms(500);
		
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
 27e:	8e 17       	cp	r24, r30
 280:	9f 07       	cpc	r25, r31
 282:	c9 f7       	brne	.-14     	; 0x276 <loop477+0x60>
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
	uint8_t curbyte,ctr,masklo;
	uint8_t sreg_prev;
	
	ws2812_DDRREG |= maskhi; // Enable output
 284:	b9 9a       	sbi	0x17, 1	; 23
	
	masklo	=~maskhi&ws2812_PORTREG;
 286:	18 b3       	in	r17, 0x18	; 24
 288:	1d 7f       	andi	r17, 0xFD	; 253
	maskhi |=        ws2812_PORTREG;
 28a:	d8 b3       	in	r29, 0x18	; 24
 28c:	d2 60       	ori	r29, 0x02	; 2
	
	sreg_prev=SREG;
 28e:	ff b6       	in	r15, 0x3f	; 63
	cli();
 290:	f8 94       	cli
 292:	f9 01       	movw	r30, r18

	while (datlen--) {
		curbyte=*data++;
 294:	c1 91       	ld	r28, Z+

		"       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
		"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
 296:	08 e0       	ldi	r16, 0x08	; 8

00000298 <loop605>:
 298:	d8 bb       	out	0x18, r29	; 24
 29a:	00 00       	nop
 29c:	00 c0       	rjmp	.+0      	; 0x29e <loop605+0x6>
 29e:	00 c0       	rjmp	.+0      	; 0x2a0 <loop605+0x8>
 2a0:	c7 ff       	sbrs	r28, 7
 2a2:	18 bb       	out	0x18, r17	; 24
 2a4:	cc 0f       	add	r28, r28
 2a6:	00 00       	nop
 2a8:	00 c0       	rjmp	.+0      	; 0x2aa <loop605+0x12>
 2aa:	00 c0       	rjmp	.+0      	; 0x2ac <loop605+0x14>
 2ac:	00 c0       	rjmp	.+0      	; 0x2ae <loop605+0x16>
 2ae:	00 c0       	rjmp	.+0      	; 0x2b0 <loop605+0x18>
 2b0:	18 bb       	out	0x18, r17	; 24
 2b2:	00 00       	nop
 2b4:	00 c0       	rjmp	.+0      	; 0x2b6 <loop605+0x1e>
 2b6:	0a 95       	dec	r16
 2b8:	79 f7       	brne	.-34     	; 0x298 <loop605>
	maskhi |=        ws2812_PORTREG;
	
	sreg_prev=SREG;
	cli();

	while (datlen--) {
 2ba:	8e 17       	cp	r24, r30
 2bc:	9f 07       	cpc	r25, r31
 2be:	51 f7       	brne	.-44     	; 0x294 <loop477+0x7e>
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	
	SREG=sreg_prev;
 2c0:	ff be       	out	0x3f, r15	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2c2:	eb ed       	ldi	r30, 0xDB	; 219
 2c4:	f5 e0       	ldi	r31, 0x05	; 5
 2c6:	31 97       	sbiw	r30, 0x01	; 1
 2c8:	f1 f7       	brne	.-4      	; 0x2c6 <loop605+0x2e>
 2ca:	00 c0       	rjmp	.+0      	; 0x2cc <loop605+0x34>
 2cc:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2ce:	ef e4       	ldi	r30, 0x4F	; 79
 2d0:	f3 ec       	ldi	r31, 0xC3	; 195
 2d2:	31 97       	sbiw	r30, 0x01	; 1
 2d4:	f1 f7       	brne	.-4      	; 0x2d2 <loop605+0x3a>
 2d6:	00 c0       	rjmp	.+0      	; 0x2d8 <loop605+0x40>
 2d8:	00 00       	nop
 2da:	61 50       	subi	r22, 0x01	; 1
			_delay_ms(10);
		}
		_delay_ms(500);
		
		//Fast fade
		for (f=0; f<255; f++){
 2dc:	09 f0       	breq	.+2      	; 0x2e0 <loop605+0x48>
 2de:	ca cf       	rjmp	.-108    	; 0x274 <loop477+0x5e>
 2e0:	ff e7       	ldi	r31, 0x7F	; 127
 2e2:	64 e8       	ldi	r22, 0x84	; 132
 2e4:	ee e1       	ldi	r30, 0x1E	; 30
 2e6:	f1 50       	subi	r31, 0x01	; 1
 2e8:	60 40       	sbci	r22, 0x00	; 0
 2ea:	e0 40       	sbci	r30, 0x00	; 0
 2ec:	e1 f7       	brne	.-8      	; 0x2e6 <loop605+0x4e>
 2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <loop605+0x58>
 2f0:	00 00       	nop
		_delay_ms(500);
		
		////////////////////////////////////////////////////////////////////////////////
		//Green
		//Fast fade
		for (f=0; f<255; f++){
 2f2:	60 e0       	ldi	r22, 0x00	; 0
 2f4:	f9 01       	movw	r30, r18
			for (i=0; i<numLeds; i++)
			{
				led[i].r = 0;
 2f6:	11 82       	std	Z+1, r1	; 0x01
				led[i].g = f;
 2f8:	60 83       	st	Z, r22
				led[i].b = 0;
 2fa:	12 82       	std	Z+2, r1	; 0x02
 2fc:	33 96       	adiw	r30, 0x03	; 3
		
		////////////////////////////////////////////////////////////////////////////////
		//Green
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
 2fe:	8e 17       	cp	r24, r30
 300:	9f 07       	cpc	r25, r31
 302:	c9 f7       	brne	.-14     	; 0x2f6 <loop605+0x5e>
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
	uint8_t curbyte,ctr,masklo;
	uint8_t sreg_prev;
	
	ws2812_DDRREG |= maskhi; // Enable output
 304:	b9 9a       	sbi	0x17, 1	; 23
	
	masklo	=~maskhi&ws2812_PORTREG;
 306:	18 b3       	in	r17, 0x18	; 24
 308:	1d 7f       	andi	r17, 0xFD	; 253
	maskhi |=        ws2812_PORTREG;
 30a:	d8 b3       	in	r29, 0x18	; 24
 30c:	d2 60       	ori	r29, 0x02	; 2
	
	sreg_prev=SREG;
 30e:	ff b6       	in	r15, 0x3f	; 63
	cli();
 310:	f8 94       	cli
 312:	f9 01       	movw	r30, r18

	while (datlen--) {
		curbyte=*data++;
 314:	c1 91       	ld	r28, Z+

		"       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
		"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
 316:	08 e0       	ldi	r16, 0x08	; 8

00000318 <loop733>:
 318:	d8 bb       	out	0x18, r29	; 24
 31a:	00 00       	nop
 31c:	00 c0       	rjmp	.+0      	; 0x31e <loop733+0x6>
 31e:	00 c0       	rjmp	.+0      	; 0x320 <loop733+0x8>
 320:	c7 ff       	sbrs	r28, 7
 322:	18 bb       	out	0x18, r17	; 24
 324:	cc 0f       	add	r28, r28
 326:	00 00       	nop
 328:	00 c0       	rjmp	.+0      	; 0x32a <loop733+0x12>
 32a:	00 c0       	rjmp	.+0      	; 0x32c <loop733+0x14>
 32c:	00 c0       	rjmp	.+0      	; 0x32e <loop733+0x16>
 32e:	00 c0       	rjmp	.+0      	; 0x330 <loop733+0x18>
 330:	18 bb       	out	0x18, r17	; 24
 332:	00 00       	nop
 334:	00 c0       	rjmp	.+0      	; 0x336 <loop733+0x1e>
 336:	0a 95       	dec	r16
 338:	79 f7       	brne	.-34     	; 0x318 <loop733>
	maskhi |=        ws2812_PORTREG;
	
	sreg_prev=SREG;
	cli();

	while (datlen--) {
 33a:	8e 17       	cp	r24, r30
 33c:	9f 07       	cpc	r25, r31
 33e:	51 f7       	brne	.-44     	; 0x314 <loop605+0x7c>
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	
	SREG=sreg_prev;
 340:	ff be       	out	0x3f, r15	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 342:	eb ed       	ldi	r30, 0xDB	; 219
 344:	f5 e0       	ldi	r31, 0x05	; 5
 346:	31 97       	sbiw	r30, 0x01	; 1
 348:	f1 f7       	brne	.-4      	; 0x346 <loop733+0x2e>
 34a:	00 c0       	rjmp	.+0      	; 0x34c <loop733+0x34>
 34c:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 34e:	ef e4       	ldi	r30, 0x4F	; 79
 350:	f3 ec       	ldi	r31, 0xC3	; 195
 352:	31 97       	sbiw	r30, 0x01	; 1
 354:	f1 f7       	brne	.-4      	; 0x352 <loop733+0x3a>
 356:	00 c0       	rjmp	.+0      	; 0x358 <loop733+0x40>
 358:	00 00       	nop
		_delay_ms(500);
		
		////////////////////////////////////////////////////////////////////////////////
		//Green
		//Fast fade
		for (f=0; f<255; f++){
 35a:	6f 5f       	subi	r22, 0xFF	; 255
 35c:	6f 3f       	cpi	r22, 0xFF	; 255
 35e:	09 f0       	breq	.+2      	; 0x362 <loop733+0x4a>
 360:	c9 cf       	rjmp	.-110    	; 0x2f4 <loop605+0x5c>
 362:	ff e7       	ldi	r31, 0x7F	; 127
 364:	64 e8       	ldi	r22, 0x84	; 132
 366:	ee e1       	ldi	r30, 0x1E	; 30
 368:	f1 50       	subi	r31, 0x01	; 1
 36a:	60 40       	sbci	r22, 0x00	; 0
 36c:	e0 40       	sbci	r30, 0x00	; 0
 36e:	e1 f7       	brne	.-8      	; 0x368 <loop733+0x50>
 370:	00 c0       	rjmp	.+0      	; 0x372 <loop733+0x5a>
 372:	00 00       	nop
 374:	6f ef       	ldi	r22, 0xFF	; 255
 376:	f9 01       	movw	r30, r18
		
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
			{
				led[i].r = 0;
 378:	11 82       	std	Z+1, r1	; 0x01
				led[i].g = 255-f;
 37a:	60 83       	st	Z, r22
				led[i].b = 0;
 37c:	12 82       	std	Z+2, r1	; 0x02
 37e:	33 96       	adiw	r30, 0x03	; 3
		}
		_delay_ms(500);
		
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
 380:	8e 17       	cp	r24, r30
 382:	9f 07       	cpc	r25, r31
 384:	c9 f7       	brne	.-14     	; 0x378 <loop733+0x60>
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
	uint8_t curbyte,ctr,masklo;
	uint8_t sreg_prev;
	
	ws2812_DDRREG |= maskhi; // Enable output
 386:	b9 9a       	sbi	0x17, 1	; 23
	
	masklo	=~maskhi&ws2812_PORTREG;
 388:	18 b3       	in	r17, 0x18	; 24
 38a:	1d 7f       	andi	r17, 0xFD	; 253
	maskhi |=        ws2812_PORTREG;
 38c:	d8 b3       	in	r29, 0x18	; 24
 38e:	d2 60       	ori	r29, 0x02	; 2
	
	sreg_prev=SREG;
 390:	ff b6       	in	r15, 0x3f	; 63
	cli();
 392:	f8 94       	cli
 394:	f9 01       	movw	r30, r18

	while (datlen--) {
		curbyte=*data++;
 396:	c1 91       	ld	r28, Z+

		"       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
		"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
 398:	08 e0       	ldi	r16, 0x08	; 8

0000039a <loop861>:
 39a:	d8 bb       	out	0x18, r29	; 24
 39c:	00 00       	nop
 39e:	00 c0       	rjmp	.+0      	; 0x3a0 <loop861+0x6>
 3a0:	00 c0       	rjmp	.+0      	; 0x3a2 <loop861+0x8>
 3a2:	c7 ff       	sbrs	r28, 7
 3a4:	18 bb       	out	0x18, r17	; 24
 3a6:	cc 0f       	add	r28, r28
 3a8:	00 00       	nop
 3aa:	00 c0       	rjmp	.+0      	; 0x3ac <loop861+0x12>
 3ac:	00 c0       	rjmp	.+0      	; 0x3ae <loop861+0x14>
 3ae:	00 c0       	rjmp	.+0      	; 0x3b0 <loop861+0x16>
 3b0:	00 c0       	rjmp	.+0      	; 0x3b2 <loop861+0x18>
 3b2:	18 bb       	out	0x18, r17	; 24
 3b4:	00 00       	nop
 3b6:	00 c0       	rjmp	.+0      	; 0x3b8 <loop861+0x1e>
 3b8:	0a 95       	dec	r16
 3ba:	79 f7       	brne	.-34     	; 0x39a <loop861>
	maskhi |=        ws2812_PORTREG;
	
	sreg_prev=SREG;
	cli();

	while (datlen--) {
 3bc:	8e 17       	cp	r24, r30
 3be:	9f 07       	cpc	r25, r31
 3c0:	51 f7       	brne	.-44     	; 0x396 <loop733+0x7e>
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	
	SREG=sreg_prev;
 3c2:	ff be       	out	0x3f, r15	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3c4:	eb ed       	ldi	r30, 0xDB	; 219
 3c6:	f5 e0       	ldi	r31, 0x05	; 5
 3c8:	31 97       	sbiw	r30, 0x01	; 1
 3ca:	f1 f7       	brne	.-4      	; 0x3c8 <loop861+0x2e>
 3cc:	00 c0       	rjmp	.+0      	; 0x3ce <loop861+0x34>
 3ce:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3d0:	ef e4       	ldi	r30, 0x4F	; 79
 3d2:	f3 ec       	ldi	r31, 0xC3	; 195
 3d4:	31 97       	sbiw	r30, 0x01	; 1
 3d6:	f1 f7       	brne	.-4      	; 0x3d4 <loop861+0x3a>
 3d8:	00 c0       	rjmp	.+0      	; 0x3da <loop861+0x40>
 3da:	00 00       	nop
 3dc:	61 50       	subi	r22, 0x01	; 1
			_delay_ms(10);
		}
		_delay_ms(500);
		
		//Fast fade
		for (f=0; f<255; f++){
 3de:	09 f0       	breq	.+2      	; 0x3e2 <loop861+0x48>
 3e0:	ca cf       	rjmp	.-108    	; 0x376 <loop733+0x5e>
 3e2:	ff e7       	ldi	r31, 0x7F	; 127
 3e4:	64 e8       	ldi	r22, 0x84	; 132
 3e6:	ee e1       	ldi	r30, 0x1E	; 30
 3e8:	f1 50       	subi	r31, 0x01	; 1
 3ea:	60 40       	sbci	r22, 0x00	; 0
 3ec:	e0 40       	sbci	r30, 0x00	; 0
 3ee:	e1 f7       	brne	.-8      	; 0x3e8 <loop861+0x4e>
 3f0:	00 c0       	rjmp	.+0      	; 0x3f2 <loop861+0x58>
 3f2:	00 00       	nop
		_delay_ms(500);
		
		////////////////////////////////////////////////////////////////////////////////
		//Blue
		//Fast fade
		for (f=0; f<255; f++){
 3f4:	60 e0       	ldi	r22, 0x00	; 0
 3f6:	f9 01       	movw	r30, r18
			for (i=0; i<numLeds; i++)
			{
				led[i].r = 0;
 3f8:	11 82       	std	Z+1, r1	; 0x01
				led[i].g = 0;
 3fa:	10 82       	st	Z, r1
				led[i].b = f;
 3fc:	62 83       	std	Z+2, r22	; 0x02
 3fe:	33 96       	adiw	r30, 0x03	; 3
		
		////////////////////////////////////////////////////////////////////////////////
		//Blue
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
 400:	8e 17       	cp	r24, r30
 402:	9f 07       	cpc	r25, r31
 404:	c9 f7       	brne	.-14     	; 0x3f8 <loop861+0x5e>
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
	uint8_t curbyte,ctr,masklo;
	uint8_t sreg_prev;
	
	ws2812_DDRREG |= maskhi; // Enable output
 406:	b9 9a       	sbi	0x17, 1	; 23
	
	masklo	=~maskhi&ws2812_PORTREG;
 408:	18 b3       	in	r17, 0x18	; 24
 40a:	1d 7f       	andi	r17, 0xFD	; 253
	maskhi |=        ws2812_PORTREG;
 40c:	d8 b3       	in	r29, 0x18	; 24
 40e:	d2 60       	ori	r29, 0x02	; 2
	
	sreg_prev=SREG;
 410:	ff b6       	in	r15, 0x3f	; 63
	cli();
 412:	f8 94       	cli
 414:	f9 01       	movw	r30, r18

	while (datlen--) {
		curbyte=*data++;
 416:	c1 91       	ld	r28, Z+

		"       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
		"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
 418:	08 e0       	ldi	r16, 0x08	; 8

0000041a <loop989>:
 41a:	d8 bb       	out	0x18, r29	; 24
 41c:	00 00       	nop
 41e:	00 c0       	rjmp	.+0      	; 0x420 <loop989+0x6>
 420:	00 c0       	rjmp	.+0      	; 0x422 <loop989+0x8>
 422:	c7 ff       	sbrs	r28, 7
 424:	18 bb       	out	0x18, r17	; 24
 426:	cc 0f       	add	r28, r28
 428:	00 00       	nop
 42a:	00 c0       	rjmp	.+0      	; 0x42c <loop989+0x12>
 42c:	00 c0       	rjmp	.+0      	; 0x42e <loop989+0x14>
 42e:	00 c0       	rjmp	.+0      	; 0x430 <loop989+0x16>
 430:	00 c0       	rjmp	.+0      	; 0x432 <loop989+0x18>
 432:	18 bb       	out	0x18, r17	; 24
 434:	00 00       	nop
 436:	00 c0       	rjmp	.+0      	; 0x438 <loop989+0x1e>
 438:	0a 95       	dec	r16
 43a:	79 f7       	brne	.-34     	; 0x41a <loop989>
	maskhi |=        ws2812_PORTREG;
	
	sreg_prev=SREG;
	cli();

	while (datlen--) {
 43c:	8e 17       	cp	r24, r30
 43e:	9f 07       	cpc	r25, r31
 440:	51 f7       	brne	.-44     	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	
	SREG=sreg_prev;
 442:	ff be       	out	0x3f, r15	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 444:	eb ed       	ldi	r30, 0xDB	; 219
 446:	f5 e0       	ldi	r31, 0x05	; 5
 448:	31 97       	sbiw	r30, 0x01	; 1
 44a:	f1 f7       	brne	.-4      	; 0x448 <loop989+0x2e>
 44c:	00 c0       	rjmp	.+0      	; 0x44e <loop989+0x34>
 44e:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 450:	ef e4       	ldi	r30, 0x4F	; 79
 452:	f3 ec       	ldi	r31, 0xC3	; 195
 454:	31 97       	sbiw	r30, 0x01	; 1
 456:	f1 f7       	brne	.-4      	; 0x454 <loop989+0x3a>
 458:	00 c0       	rjmp	.+0      	; 0x45a <loop989+0x40>
 45a:	00 00       	nop
		_delay_ms(500);
		
		////////////////////////////////////////////////////////////////////////////////
		//Blue
		//Fast fade
		for (f=0; f<255; f++){
 45c:	6f 5f       	subi	r22, 0xFF	; 255
 45e:	6f 3f       	cpi	r22, 0xFF	; 255
 460:	09 f0       	breq	.+2      	; 0x464 <loop989+0x4a>
 462:	c9 cf       	rjmp	.-110    	; 0x3f6 <loop861+0x5c>
 464:	ff e7       	ldi	r31, 0x7F	; 127
 466:	64 e8       	ldi	r22, 0x84	; 132
 468:	ee e1       	ldi	r30, 0x1E	; 30
 46a:	f1 50       	subi	r31, 0x01	; 1
 46c:	60 40       	sbci	r22, 0x00	; 0
 46e:	e0 40       	sbci	r30, 0x00	; 0
 470:	e1 f7       	brne	.-8      	; 0x46a <loop989+0x50>
 472:	00 c0       	rjmp	.+0      	; 0x474 <loop989+0x5a>
 474:	00 00       	nop
 476:	6f ef       	ldi	r22, 0xFF	; 255
 478:	f9 01       	movw	r30, r18
		
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
			{
				led[i].r = 0;
 47a:	11 82       	std	Z+1, r1	; 0x01
				led[i].g = 0;
 47c:	10 82       	st	Z, r1
				led[i].b = 255-f;
 47e:	62 83       	std	Z+2, r22	; 0x02
 480:	33 96       	adiw	r30, 0x03	; 3
		}
		_delay_ms(500);
		
		//Fast fade
		for (f=0; f<255; f++){
			for (i=0; i<numLeds; i++)
 482:	8e 17       	cp	r24, r30
 484:	9f 07       	cpc	r25, r31
 486:	c9 f7       	brne	.-14     	; 0x47a <loop989+0x60>
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
	uint8_t curbyte,ctr,masklo;
	uint8_t sreg_prev;
	
	ws2812_DDRREG |= maskhi; // Enable output
 488:	b9 9a       	sbi	0x17, 1	; 23
	
	masklo	=~maskhi&ws2812_PORTREG;
 48a:	18 b3       	in	r17, 0x18	; 24
 48c:	1d 7f       	andi	r17, 0xFD	; 253
	maskhi |=        ws2812_PORTREG;
 48e:	d8 b3       	in	r29, 0x18	; 24
 490:	d2 60       	ori	r29, 0x02	; 2
	
	sreg_prev=SREG;
 492:	ff b6       	in	r15, 0x3f	; 63
	cli();
 494:	f8 94       	cli
 496:	f9 01       	movw	r30, r18

	while (datlen--) {
		curbyte=*data++;
 498:	c1 91       	ld	r28, Z+

		"       dec   %0    \n\t"    //  '1' [+2] '0' [+2]
		"       brne  loop%=\n\t"    //  '1' [+3] '0' [+4]
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
 49a:	08 e0       	ldi	r16, 0x08	; 8

0000049c <loop1117>:
 49c:	d8 bb       	out	0x18, r29	; 24
 49e:	00 00       	nop
 4a0:	00 c0       	rjmp	.+0      	; 0x4a2 <loop1117+0x6>
 4a2:	00 c0       	rjmp	.+0      	; 0x4a4 <loop1117+0x8>
 4a4:	c7 ff       	sbrs	r28, 7
 4a6:	18 bb       	out	0x18, r17	; 24
 4a8:	cc 0f       	add	r28, r28
 4aa:	00 00       	nop
 4ac:	00 c0       	rjmp	.+0      	; 0x4ae <loop1117+0x12>
 4ae:	00 c0       	rjmp	.+0      	; 0x4b0 <loop1117+0x14>
 4b0:	00 c0       	rjmp	.+0      	; 0x4b2 <loop1117+0x16>
 4b2:	00 c0       	rjmp	.+0      	; 0x4b4 <loop1117+0x18>
 4b4:	18 bb       	out	0x18, r17	; 24
 4b6:	00 00       	nop
 4b8:	00 c0       	rjmp	.+0      	; 0x4ba <loop1117+0x1e>
 4ba:	0a 95       	dec	r16
 4bc:	79 f7       	brne	.-34     	; 0x49c <loop1117>
	maskhi |=        ws2812_PORTREG;
	
	sreg_prev=SREG;
	cli();

	while (datlen--) {
 4be:	e8 17       	cp	r30, r24
 4c0:	f9 07       	cpc	r31, r25
 4c2:	51 f7       	brne	.-44     	; 0x498 <loop989+0x7e>
		:	"=&d" (ctr)
		:	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
		);
	}
	
	SREG=sreg_prev;
 4c4:	ff be       	out	0x3f, r15	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4c6:	eb ed       	ldi	r30, 0xDB	; 219
 4c8:	f5 e0       	ldi	r31, 0x05	; 5
 4ca:	31 97       	sbiw	r30, 0x01	; 1
 4cc:	f1 f7       	brne	.-4      	; 0x4ca <loop1117+0x2e>
 4ce:	00 c0       	rjmp	.+0      	; 0x4d0 <loop1117+0x34>
 4d0:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4d2:	ef e4       	ldi	r30, 0x4F	; 79
 4d4:	f3 ec       	ldi	r31, 0xC3	; 195
 4d6:	31 97       	sbiw	r30, 0x01	; 1
 4d8:	f1 f7       	brne	.-4      	; 0x4d6 <loop1117+0x3a>
 4da:	00 c0       	rjmp	.+0      	; 0x4dc <loop1117+0x40>
 4dc:	00 00       	nop
 4de:	61 50       	subi	r22, 0x01	; 1
			_delay_ms(10);
		}
		_delay_ms(500);
		
		//Fast fade
		for (f=0; f<255; f++){
 4e0:	09 f0       	breq	.+2      	; 0x4e4 <loop1117+0x48>
 4e2:	ca cf       	rjmp	.-108    	; 0x478 <loop989+0x5e>
 4e4:	ff e7       	ldi	r31, 0x7F	; 127
 4e6:	64 e8       	ldi	r22, 0x84	; 132
 4e8:	ee e1       	ldi	r30, 0x1E	; 30
 4ea:	f1 50       	subi	r31, 0x01	; 1
 4ec:	60 40       	sbci	r22, 0x00	; 0
 4ee:	e0 40       	sbci	r30, 0x00	; 0
 4f0:	e1 f7       	brne	.-8      	; 0x4ea <loop1117+0x4e>
 4f2:	00 c0       	rjmp	.+0      	; 0x4f4 <loop1117+0x58>
 4f4:	00 00       	nop
 4f6:	ae cd       	rjmp	.-1188   	; 0x54 <main+0x10>

000004f8 <_exit>:
 4f8:	f8 94       	cli

000004fa <__stop_program>:
 4fa:	ff cf       	rjmp	.-2      	; 0x4fa <__stop_program>
